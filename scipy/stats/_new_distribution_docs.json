{
    "Normal": "\nNormal distribution with prescribed mean and standard deviation.\n\nThe probability density function of the normal distribution is:\n\n.. math::\n\n    f(x) = \\frac{1}{\\sigma \\sqrt{2 \\pi}} \\exp {\n        \\left( -\\frac{1}{2}\\left( \\frac{x - \\mu}{\\sigma} \\right)^2 \\right)}\n\nfor :math:`x` in (-\\infty, \\infty).\nThis class accepts one parameterization:\n`mu` for :math:`\\mu \\in (-\\infty, \\infty)`, `sigma` for :math:`\\sigma \\in (0, \\infty)`.\n\n\nAttributes\n----------\ncache_policy\n    {None, \"no_cache\"}:\n    Specifies the extent to which intermediate results are cached. Left\n    unspecified, intermediate results of some calculations (e.g. distribution\n    support, moments, etc.) are cached to improve performance of future\n    calculations. Pass ``'no_cache'`` to reduce memory reserved by the class\n    instance.\ntol\n    positive float:\n    The desired relative tolerance of calculations. Left unspecified,\n    calculations may be faster; when provided, calculations may be\n    more likely to meet the desired accuracy.\nvalidation_policy\n    {None, \"skip_all\"}:\n    Specifies the level of input validation to perform. Left unspecified,\n    input validation is performed to ensure appropriate behavior in edge\n    case (e.g. parameters out of domain, argument outside of distribution\n    support, etc.) and improve consistency of output dtype, shape, etc.\n    Use ``'skip_all'`` to avoid the computational overhead of these\n    checks when rough edges are acceptable.\n\nMethods\n-------\nccdf\n    Complementary cumulative distribution function\n    \n    The complementary cumulative distribution function (\"CCDF\"), denoted\n    :math:`G(x)`, is the complement of the cumulative distribution function\n    :math:`F(x)`; i.e., probability the random variable :math:`X` will\n    assume a value greater than :math:`x`:\n    \n    .. math::\n    \n        G(x) = 1 - F(x) = P(X > x)\n    \n    A two-argument variant of this function is:\n    \n    .. math::\n    \n        G(x, y) = 1 - F(x, y) = P(X < x \\text{ or } X > y)\n    \n    `ccdf` accepts `x` for :math:`x` and `y` for :math:`y`.\n    \n    Parameters\n    ----------\n    x, y : array_like\n        The arguments of the CCDF. `x` is required; `y` is optional.\n    method : {None, 'formula', 'logexp', 'complement', 'quadrature', 'addition'}\n        The strategy used to evaluate the CCDF.\n        By default (``None``), the infrastructure chooses between the\n        following options, listed in order of precedence.\n    \n        - ``'formula'``: use a formula for the CCDF itself\n        - ``'logexp'``: evaluate the log-CCDF and exponentiate\n        - ``'complement'``: evaluate the CDF and take the complement\n        - ``'quadrature'``: numerically integrate the PDF\n    \n        The two-argument form chooses between:\n    \n        - ``'formula'``: use a formula for the CCDF itself\n        - ``'addition'``: compute the CDF at `x` and the CCDF at `y`, then add\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a ``NotImplementedError``\n        will be raised.\n    \n    Returns\n    -------\n    out : array\n        The CCDF evaluated at the provided argument(s).\n    \n    See Also\n    --------\n    cdf\n    logccdf\n    \n    Notes\n    -----\n    Suppose a continuous probability distribution has support :math:`[l, r]`.\n    The CCDF :math:`G(x)` is related to the probability density function\n    :math:`f(x)` by:\n    \n    .. math::\n    \n        G(x) = \\int_x^r f(u) du\n    \n    The two argument version is:\n    \n    .. math::\n    \n        G(x, y) = \\int_l^x f(u) du + \\int_y^r f(u) du\n    \n    The CCDF returns its minimum value of :math:`0` for :math:`x \u2265 r`\n    and its maximum value of :math:`1` for :math:`x \u2264 l`.\n    \n    The CCDF is also known as the \"survival function\".\n    \n    References\n    ----------\n    .. [1] Cumulative distribution function, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Cumulative_distribution_function#Derived_functions\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> import numpy as np\n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=-0.5, b=0.5)\n    \n    Evaluate the CCDF at the desired argument:\n    \n    >>> X.ccdf(0.25)\n    0.25\n    >>> np.allclose(X.ccdf(0.25), 1-X.cdf(0.25))\n    True\n    \n    Evaluate the complement of the cumulative probability between two arguments:\n    \n    >>> X.ccdf(-0.25, 0.25) == X.cdf(-0.25) + X.ccdf(0.25)\n    True\ncdf\n    Cumulative distribution function\n    \n    The cumulative distribution function (\"CDF\"), denoted :math:`F(x)`, is\n    the probability the random variable :math:`X` will assume a value\n    less than or equal to :math:`x`:\n    \n    .. math::\n    \n        F(x) = P(X \u2264 x)\n    \n    A two-argument variant of this function is also defined as the\n    probability the random variable :math:`X` will assume a value between\n    :math:`x` and :math:`y`.\n    \n    .. math::\n    \n        F(x, y) = P(x \u2264 X \u2264 y)\n    \n    `cdf` accepts `x` for :math:`x` and `y` for :math:`y`.\n    \n    Parameters\n    ----------\n    x, y : array_like\n        The arguments of the CDF. `x` is required; `y` is optional.\n    method : {None, 'formula', 'logexp', 'complement', 'quadrature', 'subtraction'}\n        The strategy used to evaluate the CDF.\n        By default (``None``), the one-argument form of the function\n        chooses between the following options, listed in order of precedence.\n    \n        - ``'formula'``: use a formula for the CDF itself\n        - ``'logexp'``: evaluate the log-CDF and exponentiate\n        - ``'complement'``: evaluate the CCDF and take the complement\n        - ``'quadrature'``: numerically integrate the PDF\n    \n        In place of ``'complement'``, the two-argument form accepts:\n    \n        - ``'subtraction'``: compute the CDF at each argument and take\n          the difference.\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a ``NotImplementedError``\n        will be raised.\n    \n    Returns\n    -------\n    out : array\n        The CDF evaluated at the provided argument(s).\n    \n    See Also\n    --------\n    logcdf\n    ccdf\n    \n    Notes\n    -----\n    Suppose a continuous probability distribution has support :math:`[l, r]`.\n    The CDF :math:`F(x)` is related to the probability density function\n    :math:`f(x)` by:\n    \n    .. math::\n    \n        F(x) = \\int_l^x f(u) du\n    \n    The two argument version is:\n    \n    .. math::\n    \n        F(x, y) = \\int_x^y f(u) du = F(y) - F(x)\n    \n    The CDF evaluates to its minimum value of :math:`0` for :math:`x \u2264 l`\n    and its maximum value of :math:`1` for :math:`x \u2265 r`.\n    \n    The CDF is also known simply as the \"distribution function\".\n    \n    References\n    ----------\n    .. [1] Cumulative distribution function, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Cumulative_distribution_function\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=-0.5, b=0.5)\n    \n    Evaluate the CDF at the desired argument:\n    \n    >>> X.cdf(0.25)\n    0.75\n    \n    Evaluate the cumulative probability between two arguments:\n    \n    >>> X.cdf(-0.25, 0.25) == X.cdf(0.25) - X.cdf(-0.25)\n    True\nentropy\n    Differential entropy\n    \n    In terms of probability density function :math:`f(x)` and support\n    :math:`\\chi`, the differential entropy (or simply \"entropy\") of a\n    continuous random variable :math:`X` is:\n    \n    .. math::\n    \n        h(X) = - \\int_{\\chi} f(x) \\log f(x) dx\n    \n    Parameters\n    ----------\n    method : {None, 'formula', 'logexp', 'quadrature'}\n        The strategy used to evaluate the entropy. By default (``None``),\n        the infrastructure chooses between the following options, listed\n        in order of precedence.\n    \n        - ``'formula'``: use a formula for the entropy itself\n        - ``'logexp'``: evaluate the log-entropy and exponentiate\n        - ``'quadrature'``: use numerical integration\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a ``NotImplementedError``\n        will be raised.\n    \n    Returns\n    -------\n    out : array\n        The entropy of the random variable.\n    \n    See Also\n    --------\n    logentropy\n    pdf\n    \n    Notes\n    -----\n    This function calculates the entropy using the natural logarithm; i.e.\n    the logarithm with base :math:`e`. Consequently, the value is expressed\n    in (dimensionless) \"units\" of nats. To convert the entropy to different\n    units (i.e. corresponding with a different base), divide the result by\n    the natural logarithm of the desired base.\n    \n    References\n    ----------\n    .. [1] Differential entropy, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Differential_entropy\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=-1., b=1.)\n    \n    Evaluate the entropy:\n    \n    >>> X.entropy()\n    0.6931471805599454\niccdf\n    Inverse complementary cumulative distribution function.\n    \n    The inverse complementary cumulative distribution function (\"inverse CCDF\"),\n    denoted :math:`G^{-1}(p)`, is the argument :math:`x` for which the\n    complementary cumulative distribution function :math:`G(x)` evaluates to\n    :math:`p`.\n    \n    .. math::\n    \n        G^{-1}(p) = x \\quad \\text{s.t.} \\quad G(x) = p\n    \n    `iccdf` accepts `p` for :math:`p \\in [0, 1]`.\n    \n    Parameters\n    ----------\n    p : array_like\n        The argument of the inverse CCDF.\n    method : {None, 'formula', 'complement', 'inversion'}\n        The strategy used to evaluate the inverse CCDF.\n        By default (``None``), the infrastructure chooses between the\n        following options, listed in order of precedence.\n    \n        - ``'formula'``: use a formula for the inverse CCDF itself\n        - ``'complement'``: evaluate the inverse CDF at the\n          complement of `p`\n        - ``'inversion'``: solve numerically for the argument at which the\n          CCDF is equal to `p`\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a ``NotImplementedError``\n        will be raised.\n    \n    Returns\n    -------\n    out : array\n        The inverse CCDF evaluated at the provided argument.\n    \n    Notes\n    -----\n    Suppose a continuous probability distribution has support :math:`[l, r]`. The\n    inverse CCDF returns its minimum value of :math:`l` at :math:`p = 1`\n    and its maximum value of :math:`r` at :math:`p = 0`. Because the CCDF\n    has range :math:`[0, 1]`, the inverse CCDF is only defined on the\n    domain :math:`[0, 1]`; for :math:`p < 0` and :math:`p > 1`, ``iccdf``\n    returns ``nan``.\n    \n    See Also\n    --------\n    icdf\n    ilogccdf\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> import numpy as np\n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=-0.5, b=0.5)\n    \n    Evaluate the inverse CCDF at the desired argument:\n    \n    >>> X.iccdf(0.25)\n    0.25\n    >>> np.allclose(X.iccdf(0.25), X.icdf(1-0.25))\n    True\n    \n    This function returns NaN when the argument is outside the domain.\n    \n    >>> X.iccdf([-0.1, 0, 1, 1.1])\n    array([ nan,  0.5, -0.5,  nan])\nicdf\n    Inverse of the cumulative distribution function.\n    \n    The inverse of the cumulative distribution function (\"inverse CDF\"),\n    denoted :math:`F^{-1}(p)`, is the argument :math:`x` for which the\n    cumulative distribution function :math:`F(x)` evaluates to :math:`p`.\n    \n    .. math::\n    \n        F^{-1}(p) = x \\quad \\text{s.t.} \\quad F(x) = p\n    \n    `icdf` accepts `p` for :math:`p \\in [0, 1]`.\n    \n    Parameters\n    ----------\n    p : array_like\n        The argument of the inverse CDF.\n    method : {None, 'formula', 'complement', 'inversion'}\n        The strategy used to evaluate the inverse CDF.\n        By default (``None``), the infrastructure chooses between the\n        following options, listed in order of precedence.\n    \n        - ``'formula'``: use a formula for the inverse CDF itself\n        - ``'complement'``: evaluate the inverse CCDF at the\n          complement of `p`\n        - ``'inversion'``: solve numerically for the argument at which the\n          CDF is equal to `p`\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a ``NotImplementedError``\n        will be raised.\n    \n    Returns\n    -------\n    out : array\n        The inverse CDF evaluated at the provided argument.\n    \n    See Also\n    --------\n    cdf\n    ilogcdf\n    \n    Notes\n    -----\n    Suppose a continuous probability distribution has support :math:`[l, r]`. The\n    inverse CDF returns its minimum value of :math:`l` at :math:`p = 0`\n    and its maximum value of :math:`r` at :math:`p = 1`. Because the CDF\n    has range :math:`[0, 1]`, the inverse CDF is only defined on the\n    domain :math:`[0, 1]`; for :math:`p < 0` and :math:`p > 1`, `icdf`\n    returns ``nan``.\n    \n    The inverse CDF is also known as the quantile function, percentile function,\n    and percent-point function.\n    \n    References\n    ----------\n    .. [1] Quantile function, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Quantile_function\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> import numpy as np\n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=-0.5, b=0.5)\n    \n    Evaluate the inverse CDF at the desired argument:\n    \n    >>> X.icdf(0.25)\n    -0.25\n    >>> np.allclose(X.cdf(X.icdf(0.25)), 0.25)\n    True\n    \n    This function returns NaN when the argument is outside the domain.\n    \n    >>> X.icdf([-0.1, 0, 1, 1.1])\n    array([ nan, -0.5,  0.5,  nan])\nilogccdf\n    Inverse of the log of the complementary cumulative distribution function.\n    \n    The inverse of the logarithm of the complementary cumulative distribution\n    function (\"inverse log-CCDF\") is the argument :math:`x` for which the logarithm\n    of the complementary cumulative distribution function :math:`\\log(G(x))`\n    evaluates to :math:`\\log(p)`.\n    \n    Mathematically, it is equivalent to :math:`G^{-1}(\\exp(y))`, where\n    :math:`y = \\log(p)`, but it may be numerically favorable compared to the naive\n    implementation (computing :math:`p = \\exp(y)`, then :math:`G^{-1}(p)`).\n    \n    `ilogccdf` accepts `logp` for :math:`\\log(p) \u2264 0`.\n    \n    Parameters\n    ----------\n    x : array_like\n        The argument of the inverse log-CCDF.\n    method : {None, 'formula', 'complement', 'inversion'}\n        The strategy used to evaluate the inverse log-CCDF.\n        By default (``None``), the infrastructure chooses between the\n        following options, listed in order of precedence.\n    \n        - ``'formula'``: use a formula for the inverse log-CCDF itself\n        - ``'complement'``: evaluate the inverse log-CDF at the\n          logarithmic complement of `x` (see Notes)\n        - ``'inversion'``: solve numerically for the argument at which the\n          log-CCDF is equal to `x`\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a ``NotImplementedError``\n        will be raised.\n    \n    Returns\n    -------\n    out : array\n        The inverse log-CCDF evaluated at the provided argument.\n    \n    Notes\n    -----\n    Suppose a continuous probability distribution has support :math:`[l, r]`. The\n    inverse log-CCDF returns its minimum value of :math:`l` at\n    :math:`\\log(p) = \\log(1) = 0` and its maximum value of :math:`r` at\n    :math:`\\log(p) = \\log(0) = -\\infty`. Because the log-CCDF has range\n    :math:`[-\\infty, 0]`, the inverse log-CDF is only defined on the\n    negative reals; for :math:`\\log(p) > 0`, `ilogccdf` returns ``nan``.\n    \n    Occasionally, it is needed to find the argument of the CCDF for which\n    the resulting probability is very close to ``0`` or ``1`` - too close to\n    represent accurately with floating point arithmetic. In many cases,\n    however, the *logarithm* of this resulting probability may be\n    represented in floating point arithmetic, in which case this function\n    may be used to find the argument of the CCDF for which the *logarithm*\n    of the resulting probability is `y = \\log(p)`.\n    \n    The \"logarithmic complement\" of a number :math:`z` is mathematically\n    equivalent to :math:`\\log(1-\\exp(z))`, but it is computed to avoid loss\n    of precision when :math:`\\exp(z)` is nearly :math:`0` or :math:`1`.\n    \n    See Also\n    --------\n    iccdf\n    ilogccdf\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> import numpy as np\n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=-0.5, b=0.5)\n    \n    Evaluate the inverse log-CCDF at the desired argument:\n    \n    >>> X.ilogccdf(-0.25)\n    -0.2788007830714034\n    >>> np.allclose(X.ilogccdf(-0.25), X.iccdf(np.exp(-0.25)))\n    True\nilogcdf\n    Inverse of the logarithm of the cumulative distribution function.\n    \n    The inverse of the logarithm of the cumulative distribution function\n    (\"inverse log-CDF\") is the argument :math:`x` for which the logarithm\n    of the cumulative distribution function :math:`\\log(F(x))` evaluates\n    to :math:`\\log(p)`.\n    \n    Mathematically, it is equivalent to :math:`F^{-1}(\\exp(y))`, where\n    :math:`y = \\log(p)`, but it may be numerically favorable compared to\n    the naive implementation (computing :math:`p = \\exp(y)`, then\n    :math:`F^{-1}(p)`).\n    \n    `ilogcdf` accepts `logp` for :math:`\\log(p) \u2264 0`.\n    \n    Parameters\n    ----------\n    logp : array_like\n        The argument of the inverse log-CDF.\n    method : {None, 'formula', 'complement', 'inversion'}\n        The strategy used to evaluate the inverse log-CDF.\n        By default (``None``), the infrastructure chooses between the\n        following options, listed in order of precedence.\n    \n        - ``'formula'``: use a formula for the inverse log-CDF itself\n        - ``'complement'``: evaluate the inverse log-CCDF at the\n          logarithmic complement of `logp` (see Notes)\n        - ``'inversion'``: solve numerically for the argument at which the\n          log-CDF is equal to `logp`\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a ``NotImplementedError``\n        will be raised.\n    \n    Returns\n    -------\n    out : array\n        The inverse log-CDF evaluated at the provided argument.\n    \n    See Also\n    --------\n    icdf\n    logcdf\n    \n    Notes\n    -----\n    Suppose a continuous probability distribution has support :math:`[l, r]`.\n    The inverse log-CDF returns its minimum value of :math:`l` at\n    :math:`\\log(p) = \\log(0) = -\\infty` and its maximum value of :math:`r` at\n    :math:`\\log(p) = \\log(1) = 0`. Because the log-CDF has range\n    :math:`[-\\infty, 0]`, the inverse log-CDF is only defined on the\n    negative reals; for :math:`\\log(p) > 0`, `ilogcdf` returns ``nan``.\n    \n    Occasionally, it is needed to find the argument of the CDF for which\n    the resulting probability is very close to ``0`` or ``1`` - too close to\n    represent accurately with floating point arithmetic. In many cases,\n    however, the *logarithm* of this resulting probability may be\n    represented in floating point arithmetic, in which case this function\n    may be used to find the argument of the CDF for which the *logarithm*\n    of the resulting probability is :math:`y = \\log(p)`.\n    \n    The \"logarithmic complement\" of a number :math:`z` is mathematically\n    equivalent to :math:`\\log(1-\\exp(z))`, but it is computed to avoid loss\n    of precision when :math:`\\exp(z)` is nearly :math:`0` or :math:`1`.\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> import numpy as np\n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=-0.5, b=0.5)\n    \n    Evaluate the inverse log-CDF at the desired argument:\n    \n    >>> X.ilogcdf(-0.25)\n    0.2788007830714034\n    >>> np.allclose(X.ilogcdf(-0.25), X.icdf(np.exp(-0.25)))\n    True\nkurtosis\n    Kurtosis (standardized fourth moment)\n    \n    By default, this is the standardized fourth moment, also known as the\n    \"non-excess\" or \"Pearson\" kurtosis (e.g. the kurtosis of the normal\n    distribution is 3). The \"excess\" or \"Fisher\" kurtosis (the standardized\n    fourth moment minus 3) is available via the `convention` parameter.\n    \n    Parameters\n    ----------\n    method : {None, 'formula', 'general', 'transform', 'normalize', 'cache'}\n        Method used to calculate the standardized fourth moment. Not\n        all methods are available for all distributions. See\n        `moment` for details.\n    convention : {'non-excess', 'excess'}\n        Two distinct conventions are available:\n    \n        - ``'non-excess'``: the standardized fourth moment (Pearson's kurtosis)\n        - ``'excess'``: the standardized fourth moment minus 3 (Fisher's kurtosis)\n    \n        The default is ``'non-excess'``.\n    \n    See Also\n    --------\n    moment\n    mean\n    variance\n    \n    References\n    ----------\n    .. [1] Kurtosis, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Kurtosis\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> from scipy import stats\n    >>> X = stats.Normal(mu=1., sigma=2.)\n    \n    Evaluate the kurtosis:\n    \n    >>> X.kurtosis()\n    3.0\n    >>> (X.kurtosis()\n    ...  == X.kurtosis(convention='excess') + 3.\n    ...  == X.moment(order=4, kind='standardized'))\n    True\nlogccdf\n    Log of the complementary cumulative distribution function\n    \n    The complementary cumulative distribution function (\"CCDF\"), denoted\n    :math:`G(x)` is the complement of the cumulative distribution function\n    :math:`F(x)`; i.e., probability the random variable :math:`X` will\n    assume a value greater than :math:`x`:\n    \n    .. math::\n    \n        G(x) = 1 - F(x) = P(X > x)\n    \n    A two-argument variant of this function is:\n    \n    .. math::\n    \n        G(x, y) = 1 - F(x, y) = P(X < x \\quad \\text{or} \\quad X > y)\n    \n    `logccdf` computes the logarithm of the complementary cumulative\n    distribution function (\"log-CCDF\"), :math:`\\log(G(x))`/:math:`\\log(G(x, y))`,\n    but it may be numerically favorable compared to the naive implementation\n    (computing the CDF and taking the logarithm).\n    \n    `logccdf` accepts `x` for :math:`x` and `y` for :math:`y`.\n    \n    Parameters\n    ----------\n    x, y : array_like\n        The arguments of the log-CCDF. `x` is required; `y` is optional.\n    method : {None, 'formula', 'logexp', 'complement', 'quadrature', 'addition'}\n        The strategy used to evaluate the log-CCDF.\n        By default (``None``), the one-argument form of the function\n        chooses between the following options, listed in order of precedence.\n    \n        - ``'formula'``: use a formula for the log CCDF itself\n        - ``'logexp'``: evaluate the CCDF and take the logarithm\n        - ``'complement'``: evaluate the log-CDF and take the\n          logarithmic complement (see Notes)\n        - ``'quadrature'``: numerically log-integrate the log-PDF\n    \n        The two-argument form chooses between:\n    \n        - ``'formula'``: use a formula for the log CCDF itself\n        - ``'addition'``: compute the log-CDF at `x` and the log-CCDF at `y`,\n          then take the logarithmic sum (see Notes)\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a ``NotImplementedError``\n        will be raised.\n    \n    Returns\n    -------\n    out : array\n        The log-CCDF evaluated at the provided argument(s).\n    \n    See Also\n    --------\n    ccdf\n    logcdf\n    \n    Notes\n    -----\n    Suppose a continuous probability distribution has support :math:`[l, r]`.\n    The log-CCDF returns its minimum value of :math:`\\log(0)=-\\infty` for\n    :math:`x \u2265 r` and its maximum value of :math:`\\log(1) = 0` for\n    :math:`x \u2264 l`.\n    \n    For distributions with infinite support, it is common for\n    `ccdf` to return a value of ``0`` when the argument\n    is theoretically within the support; this can occur because the true value\n    of the CCDF is too small to be represented by the chosen dtype. The log\n    of the CCDF, however, will often be finite (not ``-inf``) over a much larger\n    domain. Similarly, `logccdf` may provided a strictly negative result with\n    arguments for which `ccdf` would return ``1.0``. Consequently, it may be\n    preferred to work with the logarithms of probabilities to avoid underflow\n    and related limitations of floating point numbers.\n    \n    The \"logarithmic complement\" of a number :math:`z` is mathematically\n    equivalent to :math:`\\log(1-\\exp(z))`, but it is computed to avoid loss\n    of precision when :math:`\\exp(z)` is nearly :math:`0` or :math:`1`.\n    Similarly, the term \"logarithmic sum\" of :math:`w` and :math:`z`\n    is used here to mean the :math:`\\log(\\exp(w)+\\exp(z))`, AKA\n    :math:`\\text{LogSumExp}(w, z)`.\n    \n    References\n    ----------\n    .. [1] Cumulative distribution function, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Cumulative_distribution_function#Derived_functions\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> import numpy as np\n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=-0.5, b=0.5)\n    \n    Evaluate the log-CCDF at the desired argument:\n    \n    >>> X.logccdf(0.25)\n    -1.3862943611198906\n    >>> np.allclose(X.logccdf(0.), np.log(X.ccdf(0.)))\n    True\nlogcdf\n    Log of the cumulative distribution function\n    \n    The cumulative distribution function (\"CDF\"), denoted :math:`F(x)`, is\n    the probability the random variable :math:`X` will assume a value\n    less than or equal to :math:`x`:\n    \n    .. math::\n    \n        F(x) = P(X \u2264 x)\n    \n    A two-argument variant of this function is also defined as the\n    probability the random variable :math:`X` will assume a value between\n    :math:`x` and :math:`y`.\n    \n    .. math::\n    \n        F(x, y) = P(x \u2264 X \u2264 y)\n    \n    `logcdf` computes the logarithm of the cumulative distribution function\n    (\"log-CDF\"), :math:`\\log(F(x))`/:math:`\\log(F(x, y))`, but it may be\n    numerically favorable compared to the naive implementation (computing\n    the CDF and taking the logarithm).\n    \n    `logcdf` accepts `x` for :math:`x` and `y` for :math:`y`.\n    \n    Parameters\n    ----------\n    x, y : array_like\n        The arguments of the log-CDF. `x` is required; `y` is optional.\n    method : {None, 'formula', 'logexp', 'complement', 'quadrature', 'subtraction'}\n        The strategy used to evaluate the log-CDF.\n        By default (``None``), the one-argument form of the function\n        chooses between the following options, listed in order of precedence.\n    \n        - ``'formula'``: use a formula for the log-CDF itself\n        - ``'logexp'``: evaluate the CDF and take the logarithm\n        - ``'complement'``: evaluate the log-CCDF and take the\n          logarithmic complement (see Notes)\n        - ``'quadrature'``: numerically log-integrate the log-PDF\n    \n        In place of ``'complement'``, the two-argument form accepts:\n    \n        - ``'subtraction'``: compute the log-CDF at each argument and take\n          the logarithmic difference (see Notes)\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a ``NotImplementedError``\n        will be raised.\n    \n    Returns\n    -------\n    out : array\n        The log-CDF evaluated at the provided argument(s).\n    \n    See Also\n    --------\n    cdf\n    logccdf\n    \n    Notes\n    -----\n    Suppose a continuous probability distribution has support :math:`[l, r]`.\n    The log-CDF evaluates to its minimum value of :math:`\\log(0) = -\\infty`\n    for :math:`x \u2264 l` and its maximum value of :math:`\\log(1) = 0` for\n    :math:`x \u2265 r`.\n    \n    For distributions with infinite support, it is common for\n    `cdf` to return a value of ``0`` when the argument\n    is theoretically within the support; this can occur because the true value\n    of the CDF is too small to be represented by the chosen dtype. `logcdf`,\n    however, will often return a finite (not ``-inf``) result over a much larger\n    domain. Similarly, `logcdf` may provided a strictly negative result with\n    arguments for which `cdf` would return ``1.0``. Consequently, it may be\n    preferred to work with the logarithms of probabilities to avoid underflow\n    and related limitations of floating point numbers.\n    \n    The \"logarithmic complement\" of a number :math:`z` is mathematically\n    equivalent to :math:`\\log(1-\\exp(z))`, but it is computed to avoid loss\n    of precision when :math:`\\exp(z)` is nearly :math:`0` or :math:`1`.\n    Similarly, the term \"logarithmic difference\" of :math:`w` and :math:`z`\n    is used here to mean :math:`\\log(\\exp(w)-\\exp(z))`.\n    \n    If ``y < x``, the CDF is negative, and therefore the log-CCDF\n    is complex with imaginary part :math:`\\pi`. For\n    consistency, the result of this function always has complex dtype\n    when `y` is provided, regardless of the value of the imaginary part.\n    \n    References\n    ----------\n    .. [1] Cumulative distribution function, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Cumulative_distribution_function\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> import numpy as np\n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=-0.5, b=0.5)\n    \n    Evaluate the log-CDF at the desired argument:\n    \n    >>> X.logcdf(0.25)\n    -0.287682072451781\n    >>> np.allclose(X.logcdf(0.), np.log(X.cdf(0.)))\n    True\nlogentropy\n    Logarithm of the differential entropy\n    \n    In terms of probability density function :math:`f(x)` and support\n    :math:`\\chi`, the differential entropy (or simply \"entropy\") of a random\n    variable :math:`X` is:\n    \n    .. math::\n    \n        h(X) = - \\int_{\\chi} f(x) \\log f(x) dx\n    \n    `logentropy` computes the logarithm of the differential entropy\n    (\"log-entropy\"), :math:`log(h(X))`, but it may be numerically favorable\n    compared to the naive implementation (computing :math:`h(X)` then\n    taking the logarithm).\n    \n    Parameters\n    ----------\n    method : {None, 'formula', 'logexp', 'quadrature}\n        The strategy used to evaluate the log-entropy. By default\n        (``None``), the infrastructure chooses between the following options,\n        listed in order of precedence.\n    \n        - ``'formula'``: use a formula for the log-entropy itself\n        - ``'logexp'``: evaluate the entropy and take the logarithm\n        - ``'quadrature'``: numerically log-integrate the logarithm of the\n          entropy integrand\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a ``NotImplementedError``\n        will be raised.\n    \n    Returns\n    -------\n    out : array\n        The log-entropy.\n    \n    See Also\n    --------\n    entropy\n    logpdf\n    \n    Notes\n    -----\n    If the entropy of a distribution is negative, then the log-entropy\n    is complex with imaginary part :math:`\\pi`. For\n    consistency, the result of this function always has complex dtype,\n    regardless of the value of the imaginary part.\n    \n    References\n    ----------\n    .. [1] Differential entropy, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Differential_entropy\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> import numpy as np\n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=-1., b=1.)\n    \n    Evaluate the log-entropy:\n    \n    >>> X.logentropy()\n    (-0.3665129205816642+0j)\n    >>> np.allclose(np.exp(X.logentropy()), X.entropy())\n    True\n    \n    For a random variable with negative entropy, the log-entropy has an\n    imaginary part equal to `np.pi`.\n    \n    >>> X = stats.Uniform(a=-.1, b=.1)\n    >>> X.entropy(), X.logentropy()\n    (-1.6094379124341007, (0.4758849953271105+3.141592653589793j))\nlogpdf\n    Log of the probability density function\n    \n    The probability density function (\"PDF\"), denoted :math:`f(x)`, is the\n    probability *per unit length* that the random variable will assume the\n    value :math:`x`. Mathematically, it can be defined as the derivative\n    of the cumulative distribution function :math:`F(x)`:\n    \n    .. math::\n    \n        f(x) = \\frac{d}{dx} F(x)\n    \n    `logpdf` computes the logarithm of the probability density function\n    (\"log-PDF\"), :math:`\\log(f(x))`, but it may be numerically favorable\n    compared to the naive implementation (computing :math:`f(x)` and\n    taking the logarithm).\n    \n    `logpdf` accepts `x` for :math:`x`.\n    \n    Parameters\n    ----------\n    x : array_like\n        The argument of the log-PDF.\n    method : {None, 'formula', 'logexp'}\n        The strategy used to evaluate the log-PDF. By default (``None``), the\n        infrastructure chooses between the following options, listed in order\n        of precedence.\n    \n        - ``'formula'``: use a formula for the log-PDF itself\n        - ``'logexp'``: evaluate the PDF and takes its logarithm\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a ``NotImplementedError``\n        will be raised.\n    \n    Returns\n    -------\n    out : array\n        The log-PDF evaluated at the argument `x`.\n    \n    See Also\n    --------\n    pdf\n    logcdf\n    \n    Notes\n    -----\n    Suppose a continuous probability distribution has support :math:`[l, r]`.\n    By definition of the support, the log-PDF evaluates to its minimum value\n    of :math:`-\\infty` (i.e. :math:`\\log(0)`) outside the support; i.e. for\n    :math:`x < l` or :math:`x > r`. The maximum of the log-PDF may be less\n    than or greater than :math:`\\log(1) = 0` because the maximum of the PDF\n    can be any positive real.\n    \n    For distributions with infinite support, it is common for `pdf` to return\n    a value of ``0`` when the argument is theoretically within the support;\n    this can occur because the true value of the PDF is too small to be\n    represented by the chosen dtype. The log-PDF, however, will often be finite\n    (not ``-inf``) over a much larger domain. Consequently, it may be preferred\n    to work with the logarithms of probabilities and probability densities to\n    avoid underflow.\n    \n    References\n    ----------\n    .. [1] Probability density function, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Probability_density_function\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> import numpy as np\n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=-1.0, b=1.0)\n    \n    Evaluate the log-PDF at the desired argument:\n    \n    >>> X.logpdf(0.5)\n    -0.6931471805599453\n    >>> np.allclose(X.logpdf(0.5), np.log(X.pdf(0.5)))\n    True\nmean\n    Mean (raw first moment about the origin)\n    \n    Parameters\n    ----------\n    method : {None, 'formula', 'transform', 'quadrature', 'cache'}\n        Method used to calculate the raw first moment. Not\n        all methods are available for all distributions. See\n        `moment` for details.\n    \n    See Also\n    --------\n    moment\n    median\n    mode\n    \n    References\n    ----------\n    .. [1] Mean, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Mean#Mean_of_a_probability_distribution\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> from scipy import stats\n    >>> X = stats.Normal(mu=1., sigma=2.)\n    \n    Evaluate the variance:\n    \n    >>> X.mean()\n    1.0\n    >>> X.mean() == X.moment(order=1, kind='raw') == X.mu\n    True\nmedian\n    Median (50th percentil)\n    \n    If a continuous random variable :math:`X` has probability :math:`0.5` of\n    taking on a value less than :math:`m`, then :math:`m` is the median.\n    That is, the median is the value :math:`m` for which:\n    \n    .. math::\n    \n        P(X \u2264 m) = 0.5 = P(X \u2265 m)\n    \n    Parameters\n    ----------\n    method : {None, 'formula', 'icdf'}\n        The strategy used to evaluate the median.\n        By default (``None``), the infrastructure chooses between the\n        following options, listed in order of precedence.\n    \n        - ``'formula'``: use a formula for the median\n        - ``'icdf'``: evaluate the inverse CDF of 0.5\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a ``NotImplementedError``\n        will be raised.\n    \n    Returns\n    -------\n    out : array\n        The median\n    \n    See Also\n    --------\n    mean\n    mode\n    icdf\n    \n    References\n    ----------\n    .. [1] Median, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Median#Probability_distributions\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=0., b=10.)\n    \n    Compute the median:\n    \n    >>> X.median()\n    5\n    >>> X.median() == X.icdf(0.5) == X.iccdf(0.5)\n    True\nmode\n    Mode (most likely value)\n    \n    Informally, the mode is a value that a random variable has the highest\n    probability (density) of assuming. That is, the mode is the element of\n    the support :math:`\\chi` that maximizes the probability density\n    function :math:`f(x)`:\n    \n    .. math::\n    \n        \\text{mode} = \\arg\\max_{x \\in \\chi} f(x)\n    \n    Parameters\n    ----------\n    method : {None, 'formula', 'optimization'}\n        The strategy used to evaluate the mode.\n        By default (``None``), the infrastructure chooses between the\n        following options, listed in order of precedence.\n    \n        - ``'formula'``: use a formula for the median\n        - ``'optimization'``: numerically maximize the PDF\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a ``NotImplementedError``\n        will be raised.\n    \n    Returns\n    -------\n    out : array\n        The mode\n    \n    See Also\n    --------\n    mean\n    median\n    pdf\n    \n    Notes\n    -----\n    For some distributions\n    \n    #. the mode is not unique (e.g. the uniform distribution);\n    #. the PDF has one or more singularities, and it is debateable whether\n       a singularity is considered to be in the domain and called the mode\n       (e.g. the gamma distribution with shape parameter less than 1); and/or\n    #. the probability density function may have one or more local maxima\n       that are not a global maximum (e.g. mixture distributions).\n    \n    In such cases, `mode` will\n    \n    #. return a single value,\n    #. consider the mode to occur at a singularity, and/or\n    #. return a local maximum which may or may not be a global maximum.\n    \n    If a formula for the mode is not specifically implemented for the\n    chosen distribution, SciPy will attempt to compute the mode\n    numerically, which may not meet the user's preferred definition of a\n    mode. In such cases, the user is encouraged to subclass the\n    distribution and override ``mode``.\n    \n    References\n    ----------\n    .. [1] Mode (statistics), *Wikipedia*,\n           https://en.wikipedia.org/wiki/Mode_(statistics)\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> from scipy import stats\n    >>> X = stats.Normal(mu=1., sigma=2.)\n    \n    Evaluate the mode:\n    \n    >>> X.mode()\n    1.0\n    \n    If the mode is not uniquely defined, ``mode`` nonetheless returns a\n    single value.\n    \n    >>> X = stats.Uniform(a=0., b=1.)\n    >>> X.mode()\n    0.5\n    \n    If this choice does not satisfy your requirements, subclass the\n    distribution and override ``mode``:\n    \n    >>> class BetterUniform(stats.Uniform):\n    ...     def mode(self):\n    ...         return self.b\n    >>> X = BetterUniform(a=0., b=1.)\n    >>> X.mode()\n    1.0\nmoment\n    Raw, central, or standard moment of positive integer order.\n    \n    In terms of probability density function :math:`f(x)` and support\n    :math:`\\chi`, the \"raw\" moment (about the origin) of order :math:`n` of\n    a random variable :math:`X` is:\n    \n    .. math::\n    \n        \\mu'_n(X) = \\int_{\\chi} x^n f(x) dx\n    \n    The \"central\" moment is the raw moment taken about the mean,\n    :math:`\\mu = \\mu'_1`:\n    \n    .. math::\n    \n        \\mu_n(X) = \\int_{\\chi} (x - \\mu) ^n f(x) dx\n    \n    The \"standardized\" moment is the central moment normalized by the\n    :math:`n^\\text{th}` power of the standard deviation\n    :math:`\\sigma = \\sqrt{\\mu_2}` to produce a scale invariant quantity:\n    \n    .. math::\n    \n        \\tilde{\\mu}_n(X) = \\frac{\\mu_n(X)}\n                                {\\sigma^n}\n    \n    Parameters\n    ----------\n    order : int\n        The integer order of the moment; i.e. :math:`n` in the formulae above.\n    kind : {'raw', 'central', 'standardized'}\n        Whether to return the raw (default), central, or standardized moment\n        defined above.\n    method : {None, 'formula', 'general', 'transform', 'normalize', 'quadrature', 'cache'}\n        The strategy used to evaluate the moment. By default (``None``),\n        the infrastructure chooses between the following options,\n        listed in order of precedence.\n    \n        - ``'cache'``: use the value of the moment most recently calculated\n          via another method\n        - ``'formula'``: use a formula for the moment itself\n        - ``'general'``: use a general result that is true for all distributions\n          with finite moments; for instance, the zeroth raw moment is\n          identically 1\n        - ``'transform'``: transform a raw moment to a central moment or\n          vice versa (see Notes)\n        - ``'normalize'``: normalize a central moment to get a standardized\n          or vice versa\n        - ``'quadrature'``: numerically integrate according to the definition\n    \n        Not all `method` options are available for all orders, kinds, and\n        distributions. If the selected `method` is not available, a\n        ``NotImplementedError`` will be raised.\n    \n    Returns\n    -------\n    out : array\n        The moment of the random variable of the specified order and kind.\n    \n    See Also\n    --------\n    pdf\n    mean\n    variance\n    standard_deviation\n    skewness\n    kurtosis\n    \n    Notes\n    -----\n    Not all distributions have finite moments of all orders; moments of some\n    orders may be undefined or infinite. If a formula for the moment is not\n    specifically implemented for the chosen distribution, SciPy will attempt\n    to compute the moment via a generic method, which may yield a finite\n    result where none exists. This is not a critical bug, but an opportunity\n    for an enhancement.\n    \n    The definition of a raw moment in the summary is specific to the raw moment\n    about the origin. The raw moment about any point :math:`a` is:\n    \n    .. math::\n    \n        E[(X-a)^n] = \\int_{\\chi} (x-a)^n f(x) dx\n    \n    In this notation, a raw moment about the origin is :math:`\\mu'_n = E[x^n]`,\n    and a central moment is :math:`\\mu_n = E[(x-\\mu)^n]`, where :math:`\\mu`\n    is the first raw moment; i.e. the mean.\n    \n    The ``'transform'`` method takes advantage of the following relationships\n    between moments taken about different points :math:`a` and :math:`b`.\n    \n    .. math::\n    \n        E[(X-b)^n] =  \\sum_{i=0}^n E[(X-a)^i] {n \\choose i} (a - b)^{n-i}\n    \n    For instance, to transform the raw moment to the central moment, we let\n    :math:`b = \\mu` and :math:`a = 0`.\n    \n    The distribution infrastructure provides flexibility for distribution\n    authors to implement separate formulas for raw moments, central moments,\n    and standardized moments of any order. By default, the moment of the\n    desired order and kind is evaluated from the formula if such a formula\n    is available; if not, the infrastructure uses any formulas that are\n    available rather than resorting directly to numerical integration.\n    For instance, if formulas for the first three raw moments are\n    available and the third standardized moments is desired, the\n    infrastructure will evaluate the raw moments and perform the transforms\n    and standardization required. The decision tree is somewhat complex,\n    but the strategy for obtaining a moment of a given order and kind\n    (possibly as an intermediate step due to the recursive nature of the\n    transform formula above) roughly follows this order of priority:\n    \n    #. Use cache (if order of same moment and kind has been calculated)\n    #. Use formula (if available)\n    #. Transform between raw and central moment and/or normalize to convert\n       between central and standardized moments (if efficient)\n    #. Use a generic result true for most distributions (if available)\n    #. Use quadrature\n    \n    References\n    ----------\n    .. [1] Moment, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Moment_(mathematics)\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> from scipy import stats\n    >>> X = stats.Normal(mu=1., sigma=2.)\n    \n    Evaluate the first raw moment:\n    \n    >>> X.moment(order=1, kind='raw')\n    1.0\n    >>> X.moment(order=1, kind='raw') == X.mean() == X.mu\n    True\n    \n    Evaluate the second central moment:\n    \n    >>> X.moment(order=2, kind='central')\n    4.0\n    >>> X.moment(order=2, kind='central') == X.variance() == X.sigma**2\n    True\n    \n    Evaluate the fourth standardized moment:\n    \n    >>> X.moment(order=4, kind='standardized')\n    3.0\n    >>> X.moment(order=4, kind='standardized') == X.kurtosis(convention='non-excess')\n    True\npdf\n    Probability density function\n    \n    The probability density function (\"PDF\"), denoted :math:`f(x)`, is the\n    probability *per unit length* that the random variable will assume the\n    value :math:`x`. Mathematically, it can be defined as the derivative\n    of the cumulative distribution function :math:`F(x)`:\n    \n    .. math::\n    \n        f(x) = \\frac{d}{dx} F(x)\n    \n    `pdf` accepts `x` for :math:`x`.\n    \n    Parameters\n    ----------\n    x : array_like\n        The argument of the PDF.\n    method : {None, 'formula', 'logexp'}\n        The strategy used to evaluate the PDF. By default (``None``), the\n        infrastructure chooses between the following options, listed in\n        order of precedence.\n    \n        - ``'formula'``: use a formula for the PDF itself\n        - ``'logexp'``: evaluate the log-PDF and exponentiate\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a ``NotImplementedError``\n        will be raised.\n    \n    Returns\n    -------\n    out : array\n        The PDF evaluated at the argument `x`.\n    \n    See Also\n    --------\n    cdf\n    logpdf\n    \n    Notes\n    -----\n    Suppose a continuous probability distribution has support :math:`[l, r]`.\n    By definition of the support, the PDF evaluates to its minimum value\n    of :math:`0` outside the support; i.e. for :math:`x < l` or\n    :math:`x > r`. The maximum of the PDF may be less than or greater than\n    :math:`1`; since the valus is a probability *density*, only its integral\n    over the support must equal :math:`1`.\n    \n    References\n    ----------\n    .. [1] Probability density function, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Probability_density_function\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=-1., b=1.)\n    \n    Evaluate the PDF at the desired argument:\n    \n    >>> X.pdf(0.25)\n    0.5\nreset_cache\n    Clear all cached values.\n    \n    To improve the speed of some calculations, the distribution's support\n    and moments are cached.\n    \n    This function is called automatically whenever the distribution\n    parameters are updated.\nsample\n    Random sample from the distribution.\n    \n    Parameters\n    ----------\n    shape : tuple of ints, default: ()\n        The shape of the sample to draw. If the parameters of the distribution\n        underlying the random variable are arrays of shape ``param_shape``,\n        the output array will be of shape ``shape + param_shape``.\n    method : {None, 'formula', 'inverse_transform'}\n        The strategy used to produce the sample. By default (``None``),\n        the infrastructure chooses between the following options,\n        listed in order of precedence.\n    \n        - ``'formula'``: an implementation specific to the distribution\n        - ``'inverse_transform'``: generate a uniformly distributed sample and\n          return the inverse CDF at these arguments.\n    \n        Not all `method` options are available for all distributions.\n        If the selected `method` is not available, a `NotImplementedError``\n        will be raised.\n    rng : `numpy.random.Generator`, optional\n        Pseudorandom number generator state. When `rng` is None, a new\n        `numpy.random.Generator` is created using entropy from the\n        operating system. Types other than `numpy.random.Generator` are\n        passed to `numpy.random.default_rng` to instantiate a `Generator`.\n    \n    References\n    ----------\n    .. [1] Sampling (statistics), *Wikipedia*,\n           https://en.wikipedia.org/wiki/Sampling_(statistics)\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> import numpy as np\n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=0., b=1.)\n    \n    Generate a pseudorandom sample:\n    \n    >>> x = X.sample((1000, 1))\n    >>> octiles = (np.arange(8) + 1) / 8\n    >>> np.count_nonzero(x <= octiles, axis=0)\n    array([ 148,  263,  387,  516,  636,  751,  865, 1000])  # may vary\n    \n    >>> X = stats.Uniform(a=np.zeros((3, 1)), b=np.ones(2))\n    >>> X.a.shape,\n    (3, 2)\n    >>> x = X.sample(shape=(5, 4))\n    >>> x.shape\n    (5, 4, 3, 2)\nskewness\n    Skewness (standardized third moment)\n    \n    Parameters\n    ----------\n    method : {None, 'formula', 'general', 'transform', 'normalize', 'cache'}\n        Method used to calculate the standardized third moment. Not\n        all methods are available for all distributions. See\n        `moment` for details.\n    \n    See Also\n    --------\n    moment\n    mean\n    variance\n    \n    References\n    ----------\n    .. [1] Skewness, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Skewness\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> from scipy import stats\n    >>> X = stats.Normal(mu=1., sigma=2.)\n    \n    Evaluate the skewness:\n    \n    >>> X.skewness()\n    0.0\n    >>> X.skewness() == X.moment(order=3, kind='standardized')\n    True\nstandard_deviation\n    Standard deviation (square root of the second central moment)\n    \n    Parameters\n    ----------\n    method : {None, 'formula', 'transform', 'normalize', 'quadrature', 'cache'}\n        Method used to calculate the central second moment. Not\n        all methods are available for all distributions. See\n        `moment` for details.\n    \n    See Also\n    --------\n    variance\n    mean\n    moment\n    \n    References\n    ----------\n    .. [1] Standard deviation, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Standard_deviation#Definition_of_population_values\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> from scipy import stats\n    >>> X = stats.Normal(mu=1., sigma=2.)\n    \n    Evaluate the standard deviation:\n    \n    >>> X.standard_deviation()\n    2.0\n    >>> X.standard_deviation() == X.moment(order=2, kind='central')**0.5 == X.sigma\n    True\nsupport\n    Support of the random variable\n    \n    The support of a random variable is set of all possible outcomes;\n    i.e., the subset of the domain of argument :math:`x` for which\n    the probability density function :math:`f(x)` is nonzero.\n    \n    This function returns lower and upper bounds of the support.\n    \n    Returns\n    -------\n    out : tuple of Array\n        The lower and upper bounds of the support.\n    \n    See Also\n    --------\n    pdf\n    \n    References\n    ----------\n    .. [1] Support (mathematics), *Wikipedia*,\n           https://en.wikipedia.org/wiki/Support_(mathematics)\n    \n    Notes\n    -----\n    Suppose a continuous probability distribution has support ``(l, r)``.\n    The following table summarizes the value returned by methods\n    of ``ContinuousDistribution`` for arguments outside the support.\n    \n    +----------------+---------------------+---------------------+\n    | Method         | Value for ``x < l`` | Value for ``x > r`` |\n    +================+=====================+=====================+\n    | ``pdf(x)``     | 0                   | 0                   |\n    +----------------+---------------------+---------------------+\n    | ``logpdf(x)``  | -inf                | -inf                |\n    +----------------+---------------------+---------------------+\n    | ``cdf(x)``     | 0                   | 1                   |\n    +----------------+---------------------+---------------------+\n    | ``logcdf(x)``  | -inf                | 0                   |\n    +----------------+---------------------+---------------------+\n    | ``ccdf(x)``    | 1                   | 0                   |\n    +----------------+---------------------+---------------------+\n    | ``logccdf(x)`` | 0                   | -inf                |\n    +----------------+---------------------+---------------------+\n    \n    For the ``cdf`` and related methods, the inequality need not be\n    strict; i.e. the tabulated value is returned when the method is\n    evaluated *at* the corresponding boundary.\n    \n    The following table summarizes the value returned by the inverse\n    methods of ``ContinuousDistribution`` for arguments at the boundaries\n    of the domain ``0`` to ``1``.\n    \n    +-------------+-----------+-----------+\n    | Method      | ``x = 0`` | ``x = 1`` |\n    +=============+===========+===========+\n    | ``icdf(x)`` | ``l``     | ``r``     |\n    +-------------+-----------+-----------+\n    | ``icdf(x)`` | ``r``     | ``l``     |\n    +-------------+-----------+-----------+\n    \n    For the inverse log-functions, the same values are returned for\n    for ``x = log(0)`` and ``x = log(1)``. All inverse functions return\n    ``nan`` when evaluated at an argument outside the domain ``0`` to ``1``.\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> from scipy import stats\n    >>> X = stats.Uniform(a=-0.5, b=0.5)\n    \n    Retrieve the support of the distribution:\n    \n    >>> X.support()\n    (-0.5, 0.5)\n    \n    For a distribution with infinite support,\n    \n    >>> X = stats.Normal()\n    >>> X.support()\n    (-inf, inf)\n    \n    Due to underflow, the numerical value returned by the PDF may be zero\n    even for arguments within the support, even if the true value is\n    nonzero. In such cases, the log-PDF may be useful.\n    \n    >>> X.pdf([-100., 100.])\n    array([0., 0.])\n    >>> X.logpdf([-100., 100.])\n    array([-5000.91893853, -5000.91893853])\n    \n    Use cases for the log-CDF and related methods are analogous.\nvariance\n    Variance (central second moment)\n    \n    Parameters\n    ----------\n    method : {None, 'formula', 'transform', 'normalize', 'quadrature', 'cache'}\n        Method used to calculate the central second moment. Not\n        all methods are available for all distributions. See\n        `moment` for details.\n    \n    See Also\n    --------\n    moment\n    standard_deviation\n    mean\n    \n    References\n    ----------\n    .. [1] Variance, *Wikipedia*,\n           https://en.wikipedia.org/wiki/Variance#Absolutely_continuous_random_variable\n    \n    Examples\n    --------\n    Instantiate a distribution with the desired parameters:\n    \n    >>> from scipy import stats\n    >>> X = stats.Normal(mu=1., sigma=2.)\n    \n    Evaluate the variance:\n    \n    >>> X.variance()\n    4.0\n    >>> X.variance() == X.moment(order=2, kind='central') == X.sigma**2\n    True\n\nExamples\n--------\nTo use the distribution class, it must be instantiated using keyword\nparameters corresponding with one of the accepted parameterizations.\n\n>>> import numpy as np\n>>> import matplotlib.pyplot as plt\n>>> from scipy import stats\n>>> from scipy.stats import Normal\n>>> X = Normal(mu=-0.81, sigma=0.69)\n\nFor convenience, the ``plot`` method can be used to visualize the density\nand other functions of the distribution.\n\n>>> X.plot()\n>>> plt.show()\n\nThe support of the underlying distribution is available using the ``support``\nmethod.\n\n>>> X.support()\n(np.float64(-inf), np.float64(inf))\n\nThe numerical values of parameters associated with all parameterizations\nare available as attributes.\n\n>>> X.mu, X.sigma\n(np.float64(-0.81), np.float64(0.69))\n\nTo evaluate the probability density function of the underlying distribution\nat argument ``x=-1.13``:\n\n>>> x = -1.13\n>>> X.pdf(x)\n0.5192263911374636\n\nThe cumulative distribution function, its complement, and the logarithm\nof these functions are evaluated similarly.\n\n>>> np.allclose(np.exp(X.logccdf(x)), 1 - X.cdf(x))\nTrue\n\nThe inverse of these functions with respect to the argument ``x`` is also\navailable.\n\n>>> logp = np.log(1 - X.ccdf(x))\n>>> np.allclose(X.ilogcdf(logp), x)\nTrue\n\nNote that distribution functions and their logarithms also have two-argument\nversions for working with the probability mass between two arguments. The\nresult tends to be more accurate than the naive implementation because it avoids\nsubtractive cancellation.\n\n>>> y = -0.56\n>>> np.allclose(X.ccdf(x, y), 1 - (X.cdf(y) - X.cdf(x)))\nTrue\n\nThere are methods for computing measures of central tendency,\ndispersion, higher moments, and entropy.\n\n>>> X.mean(), X.median(), X.mode()\n(np.float64(-0.81), np.float64(-0.81), np.float64(-0.81))\n>>> X.variance(), X.standard_deviation()\n(np.float64(0.4760999999999999), np.float64(0.69))\n>>> X.skewness(), X.kurtosis()\n(np.float64(0.0), np.float64(3.0))\n>>> np.allclose(X.moment(order=6, kind='standardized'),\n...             X.moment(order=6, kind='central') / X.variance()**3)\nTrue\n>>> np.allclose(np.exp(X.logentropy()), X.entropy())\nTrue\n\nPseudo-random samples can be drawn from\nthe underlying distribution using ``sample``.\n\n>>> X.sample(shape=(4,))\narray([-0.88381329, -1.16142763, -1.44590098, -0.7918882 ])  # may vary\n\n"
}