import warnings

import pytest
import numpy as np
from numpy.testing import assert_allclose
from scipy import linalg


real_floating = [np.float32, np.float64]
complex_floating = [np.complex64, np.complex128]
floating = real_floating + complex_floating


def get_random(shape, *, dtype, rng):
    A = rng.random(shape)
    if np.issubdtype(dtype, np.complexfloating):
        A = A + rng.random(shape) * 1j
    return A.astype(dtype)

def get_nearly_hermitian(shape, dtype, atol, rng):
    # Generate a batch of nearly Hermitian matrices with specified
    # `shape` and `dtype`. `atol` controls the level of noise in
    # Hermitian-ness to by generated by `rng`.
    A = rng.random(shape).astype(dtype)
    At = np.conj(A.swapaxes(-1, -2))
    noise = rng.standard_normal(size=A.shape).astype(dtype) * atol
    return A + At + noise


class TestMatrixInScalarOut:

    def batch_test(self, fun, A, core_dim=2, args=(), kwargs=None, dtype=None):
        kwargs = {} if kwargs is None else kwargs
        res = fun(A, *args, **kwargs)
        batch_shape = A.shape[:-core_dim]
        for i in range(batch_shape[0]):
            for j in range(batch_shape[1]):
                ref = np.asarray(fun(A[i, j], *args, **kwargs))
                assert_allclose(res[i, j], ref)
                assert np.shape(res[i, j]) == ref.shape

        out_dtype = ref.dtype if dtype is None else dtype
        assert res.dtype == out_dtype
        return res

    @pytest.fixture
    def rng(self):
        return np.random.default_rng(8342310302941288912051)

    @pytest.mark.parametrize('dtype', floating)
    def test_expm_cond(self, dtype, rng):
        A = rng.random((5, 3, 4, 4)).astype(dtype)
        self.batch_test(linalg.expm_cond, A)

    @pytest.mark.parametrize('dtype', floating)
    def test_issymmetric(self, dtype, rng):
        A = get_nearly_hermitian((5, 3, 4, 4), dtype, 3e-4, rng)
        res = self.batch_test(linalg.issymmetric, A, kwargs=dict(atol=1e-3))
        assert not np.all(res)  # ensure test is not trivial: not all True or False;
        assert np.any(res)      # also confirms that `atol` is passed to issymmetric

    @pytest.mark.parametrize('dtype', floating)
    def test_ishermitian(self, dtype, rng):
        A = get_nearly_hermitian((5, 3, 4, 4), dtype, 3e-4, rng)
        res = self.batch_test(linalg.ishermitian, A, kwargs=dict(atol=1e-3))
        assert not np.all(res)  # ensure test is not trivial: not all True or False;
        assert np.any(res)      # also confirms that `atol` is passed to ishermitian

    @pytest.mark.parametrize('dtype', floating)
    def test_diagsvd(self, dtype, rng):
        A = rng.random((5, 3, 4)).astype(dtype)
        self.batch_test(linalg.diagsvd, A, args=(6, 4), core_dim=1)

    @pytest.mark.parametrize('fun', [linalg.inv, linalg.sqrtm, linalg.signm,
                                     linalg.sinm, linalg.cosm, linalg.tanhm,
                                     linalg.sinhm, linalg.coshm, linalg.tanhm])
    @pytest.mark.parametrize('dtype', floating)
    def test_matmat(self, fun, dtype, rng):  # matrix in, matrix out
        A = get_random((5, 3, 4, 4), dtype=dtype, rng=rng)
        self.batch_test(fun, A)

    @pytest.mark.parametrize('dtype', floating)
    def test_null_space(self, dtype, rng):
        A = get_random((5, 3, 4, 6), dtype=dtype, rng=rng)
        self.batch_test(linalg.null_space, A)

    @pytest.mark.parametrize('dtype', floating)
    def test_funm(self, dtype, rng):
        A = get_random((2, 4, 3, 3), dtype=dtype, rng=rng)
        self.batch_test(linalg.funm, A, kwargs=dict(func=np.sin))

    @pytest.mark.parametrize('dtype', floating)
    def test_fractional_matrix_power(self, dtype, rng):
        A = get_random((2, 4, 3, 3), dtype=dtype, rng=rng)
        self.batch_test(linalg.fractional_matrix_power, A, args=(1.5,))

    @pytest.mark.parametrize('dtype', floating)
    def test_logm(self, dtype, rng):
        with warnings.catch_warnings():  # "result not accurate"
            warnings.simplefilter("ignore", RuntimeWarning)
            A = get_random((5, 3, 4, 4), dtype=dtype, rng=rng)
            A = A + 3*np.eye(4)  # avoid complex output for real input
            self.batch_test(linalg.logm, A)
